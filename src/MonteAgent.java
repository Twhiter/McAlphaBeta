import info.kwarc.kalah.Agent;
import info.kwarc.kalah.KalahState;
import info.kwarc.kalah.KalahState.Player;
import info.kwarc.kalah.ProtocolManager;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static java.lang.Thread.sleep;

public class MonteAgent extends Agent {


    static final double MAX = 10000;
    static int maxDepth = 3;
    static int maxExtendedDepth = 3;

    static int iteration = 400000;
    static double C = 6;




    public MonteAgent(String host, Integer port, ProtocolManager.ConnectionType conType) throws FileNotFoundException {
        super(
                host,
                port,
                conType,
                "MCTS 3 Alpha beta 4",
                "Xinyuan ", // authors go here
                "", // description goes here
                "Test", // token goes here
                true // don't print network communication
        );

        AlphaBeta.agent = this;
    }

    public static void main(String[] args) throws InterruptedException {

        while (true) {
            try {
                // Init agent
                MonteAgent agent = new MonteAgent("localhost", 2671, ProtocolManager.ConnectionType.TCP);

                // Connect to the server and play games until something happens
                agent.run();
            } catch (IOException e) {
                e.printStackTrace();
            }
            // Wait 10 seconds before trying again
            sleep(10_000);
        }

    }

    public boolean shouldStopWrapper() {
        return this.shouldStop();
    }

    @Override
    public void search(KalahState ks) throws IOException {
        config(ks);

        submitMove(ks.randomLegalMove());

        TreeNode root = new TreeNode(ks);
        TreeNode best;

        if (root.s.result() != KalahState.GameResult.UNDECIDED)
            return;

        for (int i = 0; i < iteration; i++) {
            if (shouldStop())
                return;

            searchHelper(root);
        }

        best = root.cs.stream().max(Comparator.comparingDouble(o -> o.value / o.count)).get();
        submitMove(best.move);

        String comment = "Best move: " + (best.move + 1) + "\n" +
                "Eval: " + best.value / best.count + "\n";

        // optional
        sendComment(comment);

//            if (((best.value / best.count) + "").equals("NaN")) {
//                throw new IOException("Float Number");
//            }




    }




    public void searchHelper(TreeNode root) {

        TreeNode currentNode = root;

        //traverse the tree generated by fixed depth expansion
        for (int i = 0; i < maxDepth; i++) {

           if (shouldStop())
                return;

            if (currentNode.s.result() != KalahState.GameResult.UNDECIDED)
                break;


            if (currentNode.cs.size() == 0)
                currentNode.expand();

            currentNode = select(currentNode);
        }


        int depth = 0;
        //to the leaf node
        while (currentNode.cs.size() != 0 && depth < maxExtendedDepth) {

            currentNode = select(currentNode);
            depth ++;
        }


        double value;


        // if the node have been computed before, save the time for alpha beta search,
        // since the computed result will be the same
        // else : get the value from a shallow alpha beta search
        if (depth == maxExtendedDepth && currentNode.count != 0) {
            value = currentNode.value / currentNode.count;
        }
        else {
            value = currentNode.evaluate();
        }

        // the maximum depth for extending
        if (depth != maxExtendedDepth && currentNode.cs.size() == 0) {
            currentNode.extend();
        }

        //back propagation
        while (currentNode != null) {

            currentNode.count ++;
            currentNode.value += value;

            currentNode = currentNode.p;
        }
    }


    public TreeNode select(TreeNode p) {

        if (p.s.getSideToMove() == KalahState.Player.SOUTH)
            return p.cs.stream().max((o1, o2) -> Double.compare(UCT(p, o1), UCT(p, o2))).get();
        else
            return p.cs.stream().min((o1, o2) -> Double.compare(UCT(p, o1), UCT(p, o2))).get();
    }


    private double UCT(TreeNode p, TreeNode c) {

        KalahState.Player before = p.s.getSideToMove();

        if (c.count == 0)
            return before == Player.SOUTH ? MAX : -MAX;

        return c.value / c.count + C * Math.sqrt(Math.log(p.count) / c.count)
                * (before == KalahState.Player.SOUTH ? 1 : -1);
    }

    public static void config(KalahState s) {

        if (s.getStoreSouth() + s.getStoreNorth() >= s.totalSeeds() / 2) {
            maxDepth = 2;
            maxExtendedDepth = 2;
            AlphaBeta.maxDepth = 6;
            iteration = 100000;

            System.out.println("Mode:Final");
        }

        else if (s.getStoreSouth() + s.getStoreNorth() >= s.totalSeeds() / 6) {

            maxDepth = 2;
            maxExtendedDepth = 3;
            AlphaBeta.maxDepth = 5;
            iteration = 200000;


            System.out.println("Mode:Medium");
        }
        else {
            maxDepth = 3;
            maxExtendedDepth = 3;
            AlphaBeta.maxDepth = 4;
            iteration = 400000;

            System.out.println("Mode:Beginning");
        }
    }

}

class TreeNode {


    public static final int MAX = 1000;


    //count for visits
    public int count = 0;
    // value accumulative
    public double value = 0;
    // move
    public int move;
    //each node in the tree represents a state
    public KalahState s;
    //parent
    public TreeNode p = null;
    //children
    public List<TreeNode> cs = new ArrayList<>();

    public TreeNode(KalahState s) {
        this.s = s;
    }


    public TreeNode(TreeNode p, KalahState s, int move) {
        this.p = p;
        this.move = move;
        this.s = s;
    }

    public TreeNode(KalahState s,int move,double value) {
        this.s = s;
        this.move = move;
        this.value = value;
    }


    public void expand() {
        for (Integer move : this.s.getMoves()) {
            KalahState newState = new KalahState(this.s);
            newState.doMove(move);
            this.cs.add(new TreeNode(this, newState, move));
        }
    }


    public double evaluate() {
        Double inc = AlphaBeta.search(this.s);
        if (inc == null)
            return 0;
        else return inc;
    }


    //extend two optimal nodes from alpha beta search as children
    public void extend() {

        //extend first optimal
        if (Util.optim1 != null)
            this.cs.add(new TreeNode(this,Util.optim1.state, Util.optim1.move));

        //extend second optimal
        if (Util.optim2 != null)
            this.cs.add(new TreeNode(this,Util.optim2.state, Util.optim2.move));
    }
}